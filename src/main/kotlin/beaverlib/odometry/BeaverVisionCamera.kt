package frc.robot.beaverlib.odometry

import edu.wpi.first.apriltag.AprilTagFieldLayout
import edu.wpi.first.math.geometry.Pose3d
import edu.wpi.first.math.geometry.Transform3d
import org.photonvision.PhotonCamera
import org.photonvision.PhotonPoseEstimator
import org.photonvision.targeting.PhotonPipelineResult

/**
 * A class that represents a Photonvision camera
 *
 * @param name The cameras name, as it appears in PhotonVision
 * @param robotToCamera The translation vector from the camera to the center of the robot
 * @param strategy The primary pose estimation strategy this camera should use
 * @param fallbackStrategy The secondary pose estimation this camera should use if [strategy] is not
 *   possible. (Will not be set if null)
 */
class BeaverVisionCamera(
    val name: String,
    val robotToCamera: Transform3d,
    layout: AprilTagFieldLayout,
    strategy: PhotonPoseEstimator.PoseStrategy,
    fallbackStrategy: PhotonPoseEstimator.PoseStrategy? = null,
) {
    val cam = PhotonCamera(name)
    /** Gets all unread results (SHOULD ONLY BE USED BY BEAVERPHOTONVISION) */
    val results: List<PhotonPipelineResult>
        get() = cam.allUnreadResults

    /** The pose estimator for this camera */
    val poseEstimator = PhotonPoseEstimator(layout, robotToCamera)

    var referencePose: Pose3d = Pose3d()

    init {}

    /**
     * Returns an estimated Pose3d given a PhotonPipelineResult (That should have been generated by
     * this camera), using multitagPNP if possible, or estimateClosestToReferencePose otherwise
     */
    fun getMultiTagPoseWithFallback(result: PhotonPipelineResult): Pose3d? {
        if (result.targets.isEmpty()) return null
        val poseEstimation =
            if (result.multiTagResult.isPresent) poseEstimator.estimateCoprocMultiTagPose(result)
            else poseEstimator.estimateClosestToReferencePose(result, referencePose)

        if (poseEstimation.isEmpty) return null
        return poseEstimation.get().estimatedPose
    }

    /**
     * Returns an estimated Pose3d given a PhotonPipelineResult (That should have been generated by
     * this camera), using multitagPNP if possible, or returning null otherwise
     */
    fun getMultiTagPose(result: PhotonPipelineResult): Pose3d? {
        if (result.targets.isEmpty()) return null
        val poseEstimation =
            if (result.targets.size <= 1)
                poseEstimator.estimateClosestToReferencePose(result, referencePose)
            else poseEstimator.estimateCoprocMultiTagPose(result)

        if (poseEstimation.isEmpty) return null
        return poseEstimation.get().estimatedPose
    }
}
